# pentest_tools.py
# Lightweight reconnaissance tools (HTTP Headers, DNS, SSL, Admin Finder).

import socket
import requests
import logging
import ssl
from datetime import datetime
from urllib.parse import urlparse

def analyze_web_headers(target: str):
    if not target.startswith("http"):
        url = f"http://{target}"
    else:
        url = target

    results = {"target": url, "headers": {}, "missing_security": []}
    
    security_headers = [
        "Strict-Transport-Security",
        "Content-Security-Policy",
        "X-Frame-Options",
        "X-Content-Type-Options",
        "X-XSS-Protection"
    ]

    try:
        r = requests.get(url, timeout=5)
        results["headers"] = dict(r.headers)
        results["server"] = r.headers.get("Server", "Unknown")
        
        for h in security_headers:
            if h not in r.headers:
                results["missing_security"].append(h)
                
        return results
    except Exception as e:
        return {"error": str(e)}

def get_dns_records(domain: str):
    records = {}
    try:
        records['A'] = socket.gethostbyname(domain)
    except: 
        records['A'] = "Not found"

    try:
        records['PTR/CNAME'] = socket.gethostbyaddr(records.get('A', ''))[0]
    except: 
        pass

    return records

def check_ssl_cert(target: str):
    if "://" in target:
        hostname = urlparse(target).netloc
    else:
        hostname = target.split("/")[0]

    if ":" in hostname:
        hostname = hostname.split(":")[0]

    context = ssl.create_default_context()
    
    try:
        with socket.create_connection((hostname, 443), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                not_after = cert['notAfter']
                expiry_date = datetime.strptime(not_after, r'%b %d %H:%M:%S %Y %Z')
                
                issuer = dict(x[0] for x in cert['issuer'])
                org = issuer.get('organizationName') or issuer.get('commonName') or "Unknown"

                return {
                    "valid": True,
                    "expiry": str(expiry_date),
                    "issuer": org
                }
    except Exception as e:
        return {"error": str(e), "valid": False}

def scan_admin_panels(target: str):
    """
    Checks for common admin panel paths.
    """
    if not target.startswith("http"):
        url_base = f"http://{target}"
    else:
        url_base = target.rstrip("/")

    paths = [
        "/admin", "/admin/", "/login", "/wp-admin", "/dashboard", 
        "/user/login", "/administrator", "/panel", "/admin-panel"
    ]
    
    found = []
    for p in paths:
        try:
            full = url_base + p
            r = requests.get(full, timeout=3, allow_redirects=False)
            # 200 OK means page exists. 302 usually means redirect to login (good sign).
            if r.status_code in [200, 301, 302, 401]:
                print(f"  [+] Found: {full} (Status: {r.status_code})")
                found.append(full)
        except:
            pass
    
    if not found:
        print("  [-] No obvious admin panels found in quick scan.")

def run_pentest_suite(target_input: str):
    report = {}
    report['web'] = analyze_web_headers(target_input)
    report['ssl'] = check_ssl_cert(target_input)
    
    if any(c.isalpha() for c in target_input):
        report['dns'] = get_dns_records(target_input)
        
    return report