# pentest_tools.py
# Lightweight reconnaissance tools (HTTP Headers, DNS, SSL).

import socket
import requests
import logging
import ssl
from datetime import datetime
from urllib.parse import urlparse

def analyze_web_headers(target: str):
    """
    Checks HTTP security headers for a target domain/IP.
    """
    if not target.startswith("http"):
        url = f"http://{target}"
    else:
        url = target

    results = {"target": url, "headers": {}, "missing_security": []}
    
    security_headers = [
        "Strict-Transport-Security",
        "Content-Security-Policy",
        "X-Frame-Options",
        "X-Content-Type-Options",
        "X-XSS-Protection"
    ]

    try:
        r = requests.get(url, timeout=5)
        results["headers"] = dict(r.headers)
        results["server"] = r.headers.get("Server", "Unknown")
        
        for h in security_headers:
            if h not in r.headers:
                results["missing_security"].append(h)
                
        return results
    except Exception as e:
        return {"error": str(e)}

def get_dns_records(domain: str):
    """
    Basic DNS enumeration.
    """
    records = {}
    try:
        records['A'] = socket.gethostbyname(domain)
    except: 
        records['A'] = "Not found"

    try:
        records['PTR/CNAME'] = socket.gethostbyaddr(records.get('A', ''))[0]
    except: 
        pass

    return records

def check_ssl_cert(target: str):
    """
    Grab SSL certificate info (Expiry, Issuer).
    """
    # Strip http/https if present
    if "://" in target:
        hostname = urlparse(target).netloc
    else:
        hostname = target.split("/")[0]

    # Remove port if present
    if ":" in hostname:
        hostname = hostname.split(":")[0]

    context = ssl.create_default_context()
    
    try:
        with socket.create_connection((hostname, 443), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                
                # Parse dates
                not_after = cert['notAfter']
                expiry_date = datetime.strptime(not_after, r'%b %d %H:%M:%S %Y %Z')
                
                # Parse issuer (simplified)
                issuer = dict(x[0] for x in cert['issuer'])
                org = issuer.get('organizationName') or issuer.get('commonName') or "Unknown"

                return {
                    "valid": True,
                    "expiry": str(expiry_date),
                    "issuer": org
                }
    except Exception as e:
        return {"error": str(e), "valid": False}

def run_pentest_suite(target_input: str):
    """
    Orchestrator for pentest tools.
    """
    report = {}
    
    # 1. Web Headers
    report['web'] = analyze_web_headers(target_input)
    
    # 2. SSL (if it looks like a domain or we forced https)
    report['ssl'] = check_ssl_cert(target_input)
    
    # 3. DNS
    if any(c.isalpha() for c in target_input):
        report['dns'] = get_dns_records(target_input)
        
    return report